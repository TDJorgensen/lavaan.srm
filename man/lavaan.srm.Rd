% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lavaan.R
\name{lavaan.srm}
\alias{lavaan.srm}
\alias{cfa.srm}
\alias{sem.srm}
\title{Fit a \code{lavaan} Model to Multivariate SRM Results}
\usage{
lavaan.srm(model, data, point = "mean", ...)

cfa.srm(model, data, point = "mean", ...)

sem.srm(model, data, point = "mean", ...)
}
\arguments{
\item{model}{\code{character} specifying an SEM.  See \code{\link[lavaan:model.syntax]{lavaan::model.syntax()}}.}

\item{data}{An object of class \code{\linkS4class{mvSRM}}}

\item{point}{\code{character} indicating choice of posterior point estimate.
Must be \verb{\%in\% c("mean", "median", "mode")}.}

\item{...}{Arguments and \code{\link[lavaan:lavOptions]{lavaan::lavOptions()}} passed to \code{\link[lavaan:lavaan]{lavaan::lavaan()}}}
}
\value{
An object of \code{class?lavaan}.
}
\description{
Estimate a structural equation model (SEM) parameters, using MCMC-estimated
summary statistics from a multivariate social relations model (mvSRM;
Nestler, \href{https://doi.org/10.3102/1076998617741106}{2018}) as data.
}
\examples{


\dontrun{

## STAGE 1: Estimate the multivariate SRM


## use example data from the ?srm::srm help page
data(data.srm01, package="srm")
## do NOT use the same case-level IDs across groups
data.srm01$egoID   <- paste(data.srm01$Group, data.srm01$Actor  , sep = "_")
data.srm01$alterID <- paste(data.srm01$Group, data.srm01$Partner, sep = "_")

srmOut <- mvsrm(data = data.srm01, rr.vars = paste0("Wert", 1:3),
                IDout = "egoID", IDin = "alterID", IDgroup = "Group",
                ## rstan::sampling() arguments to run this quickly
                chains = 2, iter = 20, seed = 12345,
                cores = ifelse(parallel::detectCores() < 3L, 1L, 2L))


## STAGE 2: Specify and fit an SEM


## specify PERSON-level model
modP <- ' ## factor loadings
  f1_out =~ Wert1_out + Wert2_out + Wert3_out
  f1_in  =~ Wert1_in  + Wert2_in  + Wert3_in

## correlated residuals
  Wert1_out ~~ Wert1_in
  Wert2_out ~~ Wert2_in
  Wert3_out ~~ Wert3_in
'

## fit CFA to PERSON-level components,
## using mvSRM-class object (Stage 1) as input data
fitP <- lavaan.srm(modP, data = srmOut, # more arguments passed to lavaan()
                   std.lv = TRUE, auto.var = TRUE, auto.cov.lv.x = TRUE)
## fitP is a lavaan-class object, so any lavaan function is available
summary(fitP, std = TRUE, rsq = TRUE) # only use Browne's residual-based test



## specify DYAD-level model
modD <- ' # equal loadings
  f1_ij =~ L1*Wert1_ij + L2*Wert2_ij + L3*Wert3_ij
  f1_ji =~ L1*Wert1_ji + L2*Wert2_ji + L3*Wert3_ji

## equal variances
  f1_ij ~~ phi*f1_ij
  f1_ji ~~ phi*f1_ji

  Wert1_ij ~~ v1*Wert1_ij
  Wert2_ij ~~ v2*Wert2_ij
  Wert3_ij ~~ v3*Wert3_ij

  Wert1_ji ~~ v1*Wert1_ji
  Wert2_ji ~~ v2*Wert2_ji
  Wert3_ji ~~ v3*Wert3_ji

## correlated residuals
  Wert1_ij ~~ Wert1_ji
  Wert2_ij ~~ Wert2_ji
  Wert3_ij ~~ Wert3_ji
'

## fit CFA to DYAD-level components,
## using wrapper analogous to lavaan::cfa()
fitD <- cfa.srm(modD, data = srmOut, std.lv = TRUE)
summary(fitD, std = TRUE, rsq = TRUE)



## Simultaneously specifying BOTH person & dyad-level models
## requires block-structured syntax, analogous to multilevel SEM.

## specify a model with cross-level measurement equivalence
modPD <- ' group: 1   # why does "group: case" not work?

  f1_out =~ L1*Wert1_out + L2*Wert2_out + L3*Wert3_out
  f1_in  =~ L1*Wert1_in  + L2*Wert2_in  + L3*Wert3_in

## correlated residuals
  Wert1_out ~~ Wert1_in
  Wert2_out ~~ Wert2_in
  Wert3_out ~~ Wert3_in

## free factor variances (use dyad-level = 1 as reference "group")
  f1_out ~~ var_perceiver*f1_out
  f1_in  ~~ var_target*f1_in


group: 2   # why does "group: dyad" not work?

  f1_ij =~ L1*Wert1_ij + L2*Wert2_ij + L3*Wert3_ij
  f1_ji =~ L1*Wert1_ji + L2*Wert2_ji + L3*Wert3_ji

## equal variances
  f1_ij ~~ var_relationship*f1_ij
  f1_ji ~~ var_relationship*f1_ji

  Wert1_ij ~~ v1*Wert1_ij
  Wert2_ij ~~ v2*Wert2_ij
  Wert3_ij ~~ v3*Wert3_ij

  Wert1_ji ~~ v1*Wert1_ji
  Wert2_ji ~~ v2*Wert2_ji
  Wert3_ji ~~ v3*Wert3_ji

## correlated residuals
  Wert1_ij ~~ Wert1_ji
  Wert2_ij ~~ Wert2_ji
  Wert3_ij ~~ Wert3_ji


## Identification constraint: Sum of factor variances == 1
  var_relationship == 1 - (var_perceiver + var_target)
## Thus, each estimated variance == proportion of total (ICC)
'

fitPD <- lavaan.srm(modPD, data = srmOut, auto.var = TRUE, auto.cov.lv.x = TRUE)

summary(fitPD, std = TRUE, rsq = TRUE)


}



}
\seealso{
\code{\linkS4class{mvSRM}}
}
